// Copyright (C) 2024 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[artifact-resolution]]
= Artifact Resolution

After constructing a dependency graph, Gradle can perform *artifact resolution* on the resolved graph.

image::dep-man-adv-4.png[]

Gradle APIs can be used to influence the process of *artifact selection* -- the mapping of a graph to a set of artifacts.

Gradle can then expose the results of artifact selection as an `ArtifactCollection`.
More commonly, the results are exposed as a `FileCollection`, which is a flat list of files.

[[sec:artifact-selection]]
== Artifact selection

*Artifact selection* operates on the dependency graph on a node-by-node basis.
Each node in the graph may expose multiple sets of artifacts, but only one of those sets may be selected.
For example, the `runtimeElements` variant of the Java plugins exposes a `jar`, `classes`, and `resources` artifact set.
These three artifact sets represent the same distributable, but in different forms.

For each node (variant) in a graph, Gradle performs attribute matching over each set of artifacts exposed by that node to determine the best artifact set.
If no artifact sets match the requested attributes, Gradle will attempt to construct an <<artifact_transforms.adoc#artifact-transforms,artifact transform>> chain to satisfy the request.

For more details on the attribute matching process, see the <<variant_attributes.adoc#sec:attribute-matching,attribute matching>> section.

[[sec:implicit-artifact-selection]]
== Implicit artifact selection

By default, the attributes used for artifact selection are the same as those used for variant selection during graph resolution.
These attributes are specified by the link:{javadocPath}/org/gradle/api/attributes/HasAttributes.html#getAttributes()[`Configuration.getAttributes()`] property.

To perform artifact selection (and implicitly, graph resolution) using these default attributes, use the `FileCollection` and `ArtifactCollection` APIs.

NOTE: Files can also be accessed from the configuration's `ResolvedConfiguration`, `LenientConfiguration`, `ResolvedArtifact` and `ResolvedDependency` APIs.
However, these APIs are in maintenance mode and are discouraged for use in new development.
These APIs perform artifact selection using the default attributes.

=== Resolving files

To resolve files, we first define a task that accepts a `ConfigurableFileCollection` as input:

====
include::sample[dir="snippets/dependencyManagement/performingResolution-artifactResolution/kotlin",files="build.gradle.kts[tags=file-resolution-task]"]
include::sample[dir="snippets/dependencyManagement/performingResolution-artifactResolution/groovy",files="build.gradle[tags=file-resolution-task]"]
====

Then, we can wire up a resolvable configuration's files to the task's input.
The `Configuration` directly implements `FileCollection` and can be wired directly.
Alternatively, wiring through `Configuration.getIncoming()` is a more explicit approach:

====
include::sample[dir="snippets/dependencyManagement/performingResolution-artifactResolution/kotlin",files="build.gradle.kts[tags=implicit-file-resolution]"]
include::sample[dir="snippets/dependencyManagement/performingResolution-artifactResolution/groovy",files="build.gradle[tags=implicit-file-resolution]"]
====

Running both of these tasks, we can see the output is identical:

----
include::{snippetsPath}/dependencyManagement/performingResolution-artifactResolution/tests/resolve-files.out[]
----

=== Resolving artifacts

Instead of consuming the files directly from the implicit artifact selection process, we can consume the artifacts, which contain both the files and the metadata.

This process is slightly more complicated, as in order to maintain Configuration Cache compatibility, we need to split the fields of `ResolvedArtifactResult` into two task inputs:

====
include::sample[dir="snippets/dependencyManagement/performingResolution-artifactResolution/kotlin",files="build.gradle.kts[tags=artifact-resolution-task]"]
include::sample[dir="snippets/dependencyManagement/performingResolution-artifactResolution/groovy",files="build.gradle[tags=artifact-resolution-task]"]
====

This task is initialized similarly to the file resolution task:

====
include::sample[dir="snippets/dependencyManagement/performingResolution-artifactResolution/kotlin",files="build.gradle.kts[tags=implicit-artifact-resolution]"]
include::sample[dir="snippets/dependencyManagement/performingResolution-artifactResolution/groovy",files="build.gradle[tags=implicit-artifact-resolution]"]
====

Running this task, we can see that file metadata is included in the output:

----
include::{snippetsPath}/dependencyManagement/performingResolution-artifactResolution/tests/resolve-artifacts.out[]
----

*[[sec:customizing-artifact-selection]]
== `ArtifactView` API

An link:{javadocPath}/org/gradle/api/artifacts/ArtifactView.html[`ArtifactView`] API operates on top of the resolved graph, defined by the link:{javadocPath}/org/gradle/api/artifacts/result/ResolutionResult.html[`ResolutionResult`].

The API provides flexible ways to access the resolved artifacts:

- link:{javadocPath}/org/gradle/api/file/FileCollection.html[`FileCollection`] - A flat list of files, which is the most commonly way to work with resolved artifacts.
- link:{javadocPath}/org/gradle/api/artifacts/ArtifactCollection.html[`ArtifactCollection`] - Offers access to both the metadata and the files of resolved artifacts, allowing for more advanced artifact handling.

When you call a configuration's `getFiles()`, Gradle selects *artifacts* based on the *attributes* used during _graph resolution_.
However, the  `ArtifactView` API is more flexible.
It allows you to resolve *artifacts* from the graph with _custom_ *attributes*.

An `ArtifactView` allows you to:

1. *Query artifacts with different attributes*:
* Suppose the graph resolved a dependency's `runtime` variant. You can use an `ArtifactView` to extract artifacts from its `api` variant instead, even if they weren't originally part of the resolved graph.
2. *Extract specific types of artifacts*:
* You can request only the `.jar` files or a specific artifact type (e.g., sources, Javadoc) by specifying an attribute like `artifactType`.
3. *Avoid side effects*:
* Using an `ArtifactView` allows you to extract artifacts without changing the underlying dependency resolution logic or configuration state.

In the following example, a producer project creates a library with typical Java library *variants* (`runtimeElements`, `apiElements`).
We also create a custom *variant* called `apiProductionElements` with the artifact `production.jar` and attribute `org.gradle.category:production`:

====
include::sample[dir="snippets/dependencyManagement/performingResolution-artifactViews-simple/kotlin",files="producer/build.gradle.kts[tags=artifact-views-lib]"]
include::sample[dir="snippets/dependencyManagement/performingResolution-artifactViews-simple/groovy",files="producer/build.gradle[tags=artifact-views-lib]"]
====

We can view the available *variants* of this library as well as their corresponding *artifacts* and *attributes* with a custom task called `checkProducerAttributes`.
Here is an abridged output showing the relevant *variants* of this library, along with their corresponding *artifacts* and *attributes*:
----
include::{snippetsPath}/dependencyManagement/performingResolution-artifactViews-simple/tests/producer-attributes.out[]
----

A Java application is a consumer of this Java library:

====
include::sample[dir="snippets/dependencyManagement/performingResolution-artifactViews-simple/kotlin",files="consumer/build.gradle.kts[tags=artifact-views-app]"]
include::sample[dir="snippets/dependencyManagement/performingResolution-artifactViews-simple/groovy",files="consumer/build.gradle[tags=artifact-views-app]"]
====

By default, the application, as the consumer, will consume the expected variant when it is run.
We can verify this with another custom task called `checkResolvedVariant` that prints out the following:

----
include::{snippetsPath}/dependencyManagement/performingResolution-artifactViews-simple/tests/consumer-attributes.out[]
----

As expected, for the `runtimeClasspath`, the application consumes the `runtimeElements` *variant* of the library which is available as the *artifact* `producer.jar`.
It uses the *attributes* `org.gradle.category:library` and `org.gradle.usage:java-runtime` to select this *variant*.

Now, let's create an `ArtifactView` to select one of the other *artifacts* provided by the library.
We do this by using an `ArtifactView` with the *attribute* `org.gradle.category:classes` so that instead of the jar file, we get the sources:

====
include::sample[dir="snippets/dependencyManagement/performingResolution-artifactViews-simple/kotlin",files="consumer/build.gradle.kts[tags=artifact-views-sel]"]
include::sample[dir="snippets/dependencyManagement/performingResolution-artifactViews-simple/groovy",files="consumer/build.gradle[tags=artifact-views-sel]"]
====

We run the task `artifactWithAttributeAndView` to see that we get the main *artifact* instead:

----
include::{snippetsPath}/dependencyManagement/performingResolution-artifactViews-simple/tests/artifactview-attributes.out[]
----

Now, let's create an `ArtifactView` to select our custom *variant* `apiProductionElements` by specifying the attribute `org.gradle.category:production` and forcing Gradle to reselect a new *variant*:

====
include::sample[dir="snippets/dependencyManagement/performingResolution-artifactViews-simple/kotlin",files="consumer/build.gradle.kts[tags=artifact-views-resel]"]
include::sample[dir="snippets/dependencyManagement/performingResolution-artifactViews-simple/groovy",files="consumer/build.gradle[tags=artifact-views-resel]"]
====

As expected, the `apiProductionElements` variant is selected along with the `production.jar` artifact:

----
include::{snippetsPath}/dependencyManagement/performingResolution-artifactViews-simple/tests/artifactview-attributes.out[]
----

